/* tslint:disable */
/* eslint-disable */
/**
 * TrainYourBrain
 * TYB reference for developers
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary POST api/auth/login
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: (loginRequest_1, ...args_1) => __awaiter(this, [loginRequest_1, ...args_1], void 0, function* (loginRequest, options = {}) {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest);
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary POST api/auth/login
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.login(loginRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['AuthApi.login']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AuthApiFp(configuration);
    return {
        /**
         *
         * @summary POST api/auth/login
         * @param {LoginRequest} loginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest, options) {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     *
     * @summary POST api/auth/login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    login(loginRequest, options) {
        return AuthApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * QuizApi - axios parameter creator
 * @export
 */
export const QuizApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {string} quizId
         * @param {string} questionId
         * @param {CheckAnswerUsingPostRequest} checkAnswerUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAnswerUsingPost: (quizId_1, questionId_1, checkAnswerUsingPostRequest_1, ...args_1) => __awaiter(this, [quizId_1, questionId_1, checkAnswerUsingPostRequest_1, ...args_1], void 0, function* (quizId, questionId, checkAnswerUsingPostRequest, options = {}) {
            // verify required parameter 'quizId' is not null or undefined
            assertParamExists('checkAnswerUsingPost', 'quizId', quizId);
            // verify required parameter 'questionId' is not null or undefined
            assertParamExists('checkAnswerUsingPost', 'questionId', questionId);
            // verify required parameter 'checkAnswerUsingPostRequest' is not null or undefined
            assertParamExists('checkAnswerUsingPost', 'checkAnswerUsingPostRequest', checkAnswerUsingPostRequest);
            const localVarPath = `/quiz/{quizId}/{questionId}/checkAnswer`
                .replace(`{${"quizId"}}`, encodeURIComponent(String(quizId)))
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(checkAnswerUsingPostRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette di inserire un quiz con delle domande
         * @param {CreateQuizUsingPostRequest} createQuizUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuizUsingPost: (createQuizUsingPostRequest_1, ...args_1) => __awaiter(this, [createQuizUsingPostRequest_1, ...args_1], void 0, function* (createQuizUsingPostRequest, options = {}) {
            // verify required parameter 'createQuizUsingPostRequest' is not null or undefined
            assertParamExists('createQuizUsingPost', 'createQuizUsingPostRequest', createQuizUsingPostRequest);
            const localVarPath = `/quiz/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createQuizUsingPostRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette eliminare fisicamente un quiz dal database
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuizUsingDelete: (quizId_1, ...args_1) => __awaiter(this, [quizId_1, ...args_1], void 0, function* (quizId, options = {}) {
            // verify required parameter 'quizId' is not null or undefined
            assertParamExists('deleteQuizUsingDelete', 'quizId', quizId);
            const localVarPath = `/quiz/delete/{quizId}`
                .replace(`{${"quizId"}}`, encodeURIComponent(String(quizId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Recupera i risultati per un determinato userID
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizResultsByUserId: (userId_1, ...args_1) => __awaiter(this, [userId_1, ...args_1], void 0, function* (userId, options = {}) {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getQuizResultsByUserId', 'userId', userId);
            const localVarPath = `/quiz/results/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette di recuperare le domanda per uno specifico topic
         * @param {string} topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizUsingGet: (topic_1, ...args_1) => __awaiter(this, [topic_1, ...args_1], void 0, function* (topic, options = {}) {
            // verify required parameter 'topic' is not null or undefined
            assertParamExists('getQuizUsingGet', 'topic', topic);
            const localVarPath = `/quiz/{topic}`
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {UserQuizResultType} [userQuizResultType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveQuizUsingPost: (userQuizResultType_1, ...args_1) => __awaiter(this, [userQuizResultType_1, ...args_1], void 0, function* (userQuizResultType, options = {}) {
            const localVarPath = `/quiz/saveQuiz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userQuizResultType, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette di nascondere o mostrarre un quiz agli studenti
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHideQuizUsingPut: (quizId_1, ...args_1) => __awaiter(this, [quizId_1, ...args_1], void 0, function* (quizId, options = {}) {
            // verify required parameter 'quizId' is not null or undefined
            assertParamExists('showHideQuizUsingPut', 'quizId', quizId);
            const localVarPath = `/quiz/show-hide/{quizId}`
                .replace(`{${"quizId"}}`, encodeURIComponent(String(quizId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * QuizApi - functional programming interface
 * @export
 */
export const QuizApiFp = function (configuration) {
    const localVarAxiosParamCreator = QuizApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {string} quizId
         * @param {string} questionId
         * @param {CheckAnswerUsingPostRequest} checkAnswerUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.checkAnswerUsingPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette di inserire un quiz con delle domande
         * @param {CreateQuizUsingPostRequest} createQuizUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuizUsingPost(createQuizUsingPostRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createQuizUsingPost(createQuizUsingPostRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.createQuizUsingPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette eliminare fisicamente un quiz dal database
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuizUsingDelete(quizId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteQuizUsingDelete(quizId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.deleteQuizUsingDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Recupera i risultati per un determinato userID
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizResultsByUserId(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuizResultsByUserId(userId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.getQuizResultsByUserId']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette di recuperare le domanda per uno specifico topic
         * @param {string} topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizUsingGet(topic, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuizUsingGet(topic, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.getQuizUsingGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {UserQuizResultType} [userQuizResultType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveQuizUsingPost(userQuizResultType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.saveQuizUsingPost(userQuizResultType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.saveQuizUsingPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette di nascondere o mostrarre un quiz agli studenti
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHideQuizUsingPut(quizId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.showHideQuizUsingPut(quizId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['QuizApi.showHideQuizUsingPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * QuizApi - factory interface
 * @export
 */
export const QuizApiFactory = function (configuration, basePath, axios) {
    const localVarFp = QuizApiFp(configuration);
    return {
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {string} quizId
         * @param {string} questionId
         * @param {CheckAnswerUsingPostRequest} checkAnswerUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options) {
            return localVarFp.checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette di inserire un quiz con delle domande
         * @param {CreateQuizUsingPostRequest} createQuizUsingPostRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuizUsingPost(createQuizUsingPostRequest, options) {
            return localVarFp.createQuizUsingPost(createQuizUsingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette eliminare fisicamente un quiz dal database
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuizUsingDelete(quizId, options) {
            return localVarFp.deleteQuizUsingDelete(quizId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Recupera i risultati per un determinato userID
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizResultsByUserId(userId, options) {
            return localVarFp.getQuizResultsByUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette di recuperare le domanda per uno specifico topic
         * @param {string} topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuizUsingGet(topic, options) {
            return localVarFp.getQuizUsingGet(topic, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette di controllare le risposte
         * @param {UserQuizResultType} [userQuizResultType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveQuizUsingPost(userQuizResultType, options) {
            return localVarFp.saveQuizUsingPost(userQuizResultType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette di nascondere o mostrarre un quiz agli studenti
         * @param {string} quizId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHideQuizUsingPut(quizId, options) {
            return localVarFp.showHideQuizUsingPut(quizId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * QuizApi - object-oriented interface
 * @export
 * @class QuizApi
 * @extends {BaseAPI}
 */
export class QuizApi extends BaseAPI {
    /**
     *
     * @summary Permette di controllare le risposte
     * @param {string} quizId
     * @param {string} questionId
     * @param {CheckAnswerUsingPostRequest} checkAnswerUsingPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options) {
        return QuizApiFp(this.configuration).checkAnswerUsingPost(quizId, questionId, checkAnswerUsingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette di inserire un quiz con delle domande
     * @param {CreateQuizUsingPostRequest} createQuizUsingPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    createQuizUsingPost(createQuizUsingPostRequest, options) {
        return QuizApiFp(this.configuration).createQuizUsingPost(createQuizUsingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette eliminare fisicamente un quiz dal database
     * @param {string} quizId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    deleteQuizUsingDelete(quizId, options) {
        return QuizApiFp(this.configuration).deleteQuizUsingDelete(quizId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Recupera i risultati per un determinato userID
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    getQuizResultsByUserId(userId, options) {
        return QuizApiFp(this.configuration).getQuizResultsByUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette di recuperare le domanda per uno specifico topic
     * @param {string} topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    getQuizUsingGet(topic, options) {
        return QuizApiFp(this.configuration).getQuizUsingGet(topic, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette di controllare le risposte
     * @param {UserQuizResultType} [userQuizResultType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    saveQuizUsingPost(userQuizResultType, options) {
        return QuizApiFp(this.configuration).saveQuizUsingPost(userQuizResultType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette di nascondere o mostrarre un quiz agli studenti
     * @param {string} quizId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuizApi
     */
    showHideQuizUsingPut(quizId, options) {
        return QuizApiFp(this.configuration).showHideQuizUsingPut(quizId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {NominaAdminRequest} [nominaAdminRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdminUsingPost: (nominaAdminRequest_1, ...args_1) => __awaiter(this, [nominaAdminRequest_1, ...args_1], void 0, function* (nominaAdminRequest, options = {}) {
            const localVarPath = `/manage-user/add-admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(nominaAdminRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {ChangePasswordRequest} [changePasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPut: (changePasswordRequest_1, ...args_1) => __awaiter(this, [changePasswordRequest_1, ...args_1], void 0, function* (changePasswordRequest, options = {}) {
            const localVarPath = `/manage-user/changepassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette di creare un nuovo utente
         * @param {UserType} [userType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST: (userType_1, ...args_1) => __awaiter(this, [userType_1, ...args_1], void 0, function* (userType, options = {}) {
            const localVarPath = `/manage-user/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userType, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette eliminare fisicamente un utente dal database
         * @param {DeleteUserRequest} [deleteUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDelete: (deleteUserRequest_1, ...args_1) => __awaiter(this, [deleteUserRequest_1, ...args_1], void 0, function* (deleteUserRequest, options = {}) {
            const localVarPath = `/manage-user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminsUsingGet: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/manage-user/get-admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary POST api/manage-user/user
         * @param {UserType} userType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: (userType_1, ...args_1) => __awaiter(this, [userType_1, ...args_1], void 0, function* (userType, options = {}) {
            // verify required parameter 'userType' is not null or undefined
            assertParamExists('getUserByUsername', 'userType', userType);
            const localVarPath = `/manage-user/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(userType, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {NominaAdminRequest} [nominaAdminRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdminUsingPost(nominaAdminRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAdminUsingPost(nominaAdminRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.addAdminUsingPost']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {ChangePasswordRequest} [changePasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPut(changePasswordRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changePasswordUsingPut(changePasswordRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.changePasswordUsingPut']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette di creare un nuovo utente
         * @param {UserType} [userType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(userType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUserUsingPOST(userType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.createUserUsingPOST']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette eliminare fisicamente un utente dal database
         * @param {DeleteUserRequest} [deleteUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDelete(deleteUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserUsingDelete(deleteUserRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.deleteUserUsingDelete']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminsUsingGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAdminsUsingGet(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.getAdminsUsingGet']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary POST api/manage-user/user
         * @param {UserType} userType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(userType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserByUsername(userType, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['UserApi.getUserByUsername']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserApiFp(configuration);
    return {
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {NominaAdminRequest} [nominaAdminRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAdminUsingPost(nominaAdminRequest, options) {
            return localVarFp.addAdminUsingPost(nominaAdminRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {ChangePasswordRequest} [changePasswordRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPut(changePasswordRequest, options) {
            return localVarFp.changePasswordUsingPut(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette di creare un nuovo utente
         * @param {UserType} [userType]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(userType, options) {
            return localVarFp.createUserUsingPOST(userType, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette eliminare fisicamente un utente dal database
         * @param {DeleteUserRequest} [deleteUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDelete(deleteUserRequest, options) {
            return localVarFp.deleteUserUsingDelete(deleteUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Permette cambiare la password di un utente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminsUsingGet(options) {
            return localVarFp.getAdminsUsingGet(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary POST api/manage-user/user
         * @param {UserType} userType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(userType, options) {
            return localVarFp.getUserByUsername(userType, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @summary Permette cambiare la password di un utente
     * @param {NominaAdminRequest} [nominaAdminRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAdminUsingPost(nominaAdminRequest, options) {
        return UserApiFp(this.configuration).addAdminUsingPost(nominaAdminRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette cambiare la password di un utente
     * @param {ChangePasswordRequest} [changePasswordRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    changePasswordUsingPut(changePasswordRequest, options) {
        return UserApiFp(this.configuration).changePasswordUsingPut(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette di creare un nuovo utente
     * @param {UserType} [userType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUserUsingPOST(userType, options) {
        return UserApiFp(this.configuration).createUserUsingPOST(userType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette eliminare fisicamente un utente dal database
     * @param {DeleteUserRequest} [deleteUserRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserUsingDelete(deleteUserRequest, options) {
        return UserApiFp(this.configuration).deleteUserUsingDelete(deleteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Permette cambiare la password di un utente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getAdminsUsingGet(options) {
        return UserApiFp(this.configuration).getAdminsUsingGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary POST api/manage-user/user
     * @param {UserType} userType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserByUsername(userType, options) {
        return UserApiFp(this.configuration).getUserByUsername(userType, options).then((request) => request(this.axios, this.basePath));
    }
}
